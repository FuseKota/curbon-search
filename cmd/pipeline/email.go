package main

import (
	"context"
	"fmt"
	"math"
	"net/smtp"
	"os"
	"strings"
	"time"
)

// EmailConfig holds email configuration
type EmailConfig struct {
	From     string   // EMAIL_FROM
	Password string   // EMAIL_PASSWORD (Gmail App Password)
	To       []string // EMAIL_TO (comma-separated list)
	SMTPHost string   // "smtp.gmail.com"
	SMTPPort string   // "587"
}

// EmailSender handles email sending
type EmailSender struct {
	config EmailConfig
}

// NewEmailSender creates a new email sender
func NewEmailSender(from, password, to string) (*EmailSender, error) {
	if from == "" {
		return nil, fmt.Errorf("EMAIL_FROM is required")
	}
	if password == "" {
		return nil, fmt.Errorf("EMAIL_PASSWORD is required (use Gmail App Password)")
	}
	if to == "" {
		return nil, fmt.Errorf("EMAIL_TO is required")
	}

	// Parse comma-separated email addresses
	toList := strings.Split(to, ",")
	for i, addr := range toList {
		toList[i] = strings.TrimSpace(addr)
	}

	return &EmailSender{
		config: EmailConfig{
			From:     from,
			Password: password,
			To:       toList,
			SMTPHost: "smtp.gmail.com",
			SMTPPort: "587",
		},
	}, nil
}

// SendHeadlinesSummary sends a plain text email with all headlines
func (es *EmailSender) SendHeadlinesSummary(ctx context.Context, headlines []NotionHeadline) error {
	if len(headlines) == 0 {
		return fmt.Errorf("no headlines to send")
	}

	// Generate email body
	body := es.generateEmailBody(headlines)

	// Generate subject
	subject := fmt.Sprintf("Carbon News Headlines - %s (%d articles)",
		time.Now().Format("2006-01-02"),
		len(headlines))

	// Build email message
	msg := es.buildEmailMessage(subject, body)

	// Send with retry
	return es.sendWithRetry(msg)
}

// generateEmailBody creates plain text email body
func (es *EmailSender) generateEmailBody(headlines []NotionHeadline) string {
	var sb strings.Builder

	// Header
	sb.WriteString("Carbon News Headlines Summary\n")
	sb.WriteString(fmt.Sprintf("Generated: %s\n\n", time.Now().Format("2006-01-02 15:04:05")))
	sb.WriteString("========================================\n")
	sb.WriteString(fmt.Sprintf("Total Headlines: %d\n", len(headlines)))
	sb.WriteString("========================================\n\n")

	// Headlines
	for i, h := range headlines {
		sb.WriteString(fmt.Sprintf("[%d] Title: \"%s\"\n", i+1, h.Title))
		sb.WriteString(fmt.Sprintf("    Source: %s\n", h.Source))
		sb.WriteString(fmt.Sprintf("    URL: %s\n", h.URL))
		sb.WriteString("\n")

		if h.AISummary != "" {
			sb.WriteString("    Summary:\n")
			// Indent summary text
			summaryLines := strings.Split(h.AISummary, "\n")
			for _, line := range summaryLines {
				if strings.TrimSpace(line) != "" {
					sb.WriteString(fmt.Sprintf("    %s\n", line))
				}
			}
		} else {
			sb.WriteString("    Summary: (No AI summary available)\n")
		}

		sb.WriteString("\n")
		sb.WriteString("----------------------------------------\n\n")
	}

	// Footer
	sb.WriteString("\n")
	sb.WriteString("Generated by carbon-relay\n")
	sb.WriteString("https://github.com/FuseKota/curbon-search\n")

	return sb.String()
}

// buildEmailMessage constructs RFC 5322 compliant email message
func (es *EmailSender) buildEmailMessage(subject, body string) []byte {
	var msg strings.Builder

	msg.WriteString(fmt.Sprintf("From: %s\r\n", es.config.From))
	msg.WriteString(fmt.Sprintf("To: %s\r\n", strings.Join(es.config.To, ", ")))
	msg.WriteString(fmt.Sprintf("Subject: %s\r\n", subject))
	msg.WriteString("Content-Type: text/plain; charset=UTF-8\r\n")
	msg.WriteString("\r\n")
	msg.WriteString(body)

	return []byte(msg.String())
}

// sendWithRetry sends email with exponential backoff retry
func (es *EmailSender) sendWithRetry(msg []byte) error {
	maxRetries := 3
	var lastErr error

	for i := 0; i < maxRetries; i++ {
		if i > 0 {
			// Exponential backoff
			wait := time.Duration(math.Pow(2, float64(i))) * time.Second
			fmt.Fprintf(os.Stderr, "Retrying email send in %v...\n", wait)
			time.Sleep(wait)
		}

		// Attempt to send
		err := es.send(msg)
		if err == nil {
			return nil
		}

		lastErr = err
		fmt.Fprintf(os.Stderr, "WARN: Email send failed (attempt %d/%d): %v\n", i+1, maxRetries, err)
	}

	return fmt.Errorf("failed to send email after %d retries: %w", maxRetries, lastErr)
}

// send sends email using Gmail SMTP
func (es *EmailSender) send(msg []byte) error {
	// Set up authentication
	auth := smtp.PlainAuth("", es.config.From, es.config.Password, es.config.SMTPHost)

	// SMTP server address
	addr := es.config.SMTPHost + ":" + es.config.SMTPPort

	// Send email
	err := smtp.SendMail(addr, auth, es.config.From, es.config.To, msg)
	if err != nil {
		return fmt.Errorf("SMTP send failed: %w (check EMAIL_PASSWORD is a Gmail App Password)", err)
	}

	return nil
}
